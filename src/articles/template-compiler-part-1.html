---
title: Template Compiler - Part 1 (DRAFT)
description: Compiling HTML (or other) templates to Wasm Components
date: 2023-01-08
---

<p>
    WebAssembly (Wasm) components are a compact, portable, and secure unit of code.
    They&apos;re a <q>compile target</q> with a binary format, not a source code language.
    So you won't write them by hand, you&apos;ll have tools to generate them for you.
</p>

<p>
    In addition to languages like Rust, C++, JavaScript, and Python,
    we can compile new languages and new takes on old languages to Wasm components.
    For example, we can compile HTML templates (or templates generally) to Wasm components
    that export a function that returns a string.
</p>

<h2>Making a Template-to-Component Compiler</h2>

<p>
    So, let's make a compiler that converts templates into components!
</p>

<p>
    To keep this manageable, I'm going to split up this project into several parts.
    I'll implement each part, and then write an article here on my website that explains it.
</p>

<h2>Chapter 1 Goal</h2>

<p>
    The goal for this chapter is to make a compiler that generates components whose type looks like this.
</p>

{% highlight "js" %}
export apply: func() -> string
{% endhighlight %}

<p>
    The resulting components contain all of the data and logic needed to create and return that string
    and can be instantiated by runtimes
    like <a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a>
    and executed to produce the desired string.
</p>

<p>
    Since runtimes like wasmtime compile to a variety of platforms, including all the big ones,
    and have bindings for common programming languages, this <q>template</q> can be used essentially everywhere.
</p>

<h2>Basic Setup</h2>

<p>
    The basic compiler command line interface needs to accept an input path, output path,
    and optionally a name chosen by the user for the template function.
    I've chosen to use the <a href="https://crates.io/crates/clap">clap</a> command line argument parsing library,
    because it is very simple and powerful.
</p>

{% highlight "rust" %}
#[derive(Parser)]
#[command(about)]
struct Args {
    #[arg(short, long)]
    input: PathBuf,
    #[arg(short, long)]
    output: PathBuf,

    // The export name for the template function
    #[arg(short, long)]
    export_name: Option<String>,
}
{% endhighlight %}

<p>
    Since we are treating the entire template string as one value with no directives,
    there isn't any parsing yet. That'll come in future chapters.
</p>

<h2>Canonical ABI</h2>

<p>
    To implement the high-level interface we defined earlier,
    we need to understand something called the canonical ABI
    which defines the way that high-level component types
    can be passed into and returned from coponents using integer values
    and the Wasm linear memory.
</p>

<figure>
    <img
        src="/tc-1/canon-abi.svg"
        width="400px"
        height="115px"
        alt="The canonical ABI connects the component model and core wasm"
    />
</figure>


<p>
    In the future, components won't be limited to just using the canonical ABI.
    They'll be able to define custom adapters that match their internal memory representation,
    but that's not available yet so we won't be using it.
</p>

<h3>Lifting and Lowering</h3>

<p>
    In the Canonical ABI, the Component Model is <q>higher</q> (as in higher-level)
    than Core Wasm and Modules.
    So, when things need to be converted upwards from Core Wasm to the Component Model, it's called <q>lifting</q>.
    Conversely, when things need to be converted downards from the Component Model to Core Wasm, it's called <q>lowering</q>.
</p>

<figure>
    <img
        src="/tc-1/lift-lower.svg"
        width="550px"
        height="350px"
        alt="Lifting types from Core Wasm to the Component Model and lowering them from Component Model to Core Wasm"
    />
</figure>

<h3>Imported and Exported Functions</h3>

<p>
    When talking about functions, the direction of lifting and lowering corresponds
    to whether the function is an export or import.
</p>

<p>
    Exported functions are defined in the inner module and lifted to the component which re-exports it.
    Imported functions are defined by a component import and lowered to the module import.
</p>

<figure>
    <img
        src="/tc-1/function-export-import.svg"
        width="700px"
        height="330px"
        alt="Diagram showing module exports being lifted to component exports, and component imports being lowed to module imports"
    />
</figure>

<p>
    For exports and imports, the arguments go in the direction from caller to callee
    and the returns go from callee to caller.
</p>

<figure>
    <img
        src="/tc-1/argument-return.svg"
        width="700px"
        height="250px"
        alt="Diagram showing export arguments being lowered and return being lifted, with import arguments being raised and return being lowered"
    />
</figure>

<h3>Template ABI</h3>

<p>
    The generated template function is exported, which means it will be defined in the module then lifted and rexported in the outer component.
</p>

<p>
    It doesn't have any arguments, which would be lowered if they did exist, and it has a single string result, which will need to be lifted.
</p>

<p>
    We will be encoding our strings in UTF-8 and so to encode a string return value we need
    both the string data and that data's index in memory and length in bytes to also be in memory.
    The index and length are encoded as 8 bytes where the first four are the index in little-endian
    and the second four are the length in little-endian.
</p>

<figure>
    <img
        src="/tc-1/string-memory.svg"
        width="700px"
        height="250px"
        alt="Diagram showing string memory being layed out with pointer and length together pointing at the text data"
    />
</figure>

<p>
    Now, to return this string we just need to return the integer index in memory of the (index,length) pair.
</p>

<h2>Generating the Module</h2>

<p>
    With all the canonical ABI details squared away, we can now generate our output module.
</p>

<h2>Final Component</h2>

WIP: this is mostly for my reference

{% highlight "lisp" %}
(component
  (core module $mod
    (type $mftype (func (result i32)))
    (func $modfunc (type $mftype) (result i32)
      i32.const 0
    )
    (memory $modmem 1)
    (export "apply" (func 0))
    (export "mem" (memory 0))
    (data $return_area (i32.const 0) "\08\00\00\00\1a\00\00\00")
    (data $template_data (i32.const 8) "Lorem ipsum dolor sit amet")
  )
  (core instance $mod (instantiate 0))
  (alias $falias core export 0 "apply" (core func $modfunc))
  (alias $malias core export 0 "mem" (core memory $modmem))
  (type $cftype (func (result string)))
  (func $compfunc (type $cftype) (canon lift (core func $falias) string-encoding=utf8 (memory $malias)))
  (export "apply" (func 0))
)
{% endhighlight %}