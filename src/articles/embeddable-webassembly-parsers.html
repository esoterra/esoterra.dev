---
title: Embeddable WebAssembly Parsers
description: How Wasm lets us write portable solutions for parsing
date: 2022-03-07
---

<p>
    Developer tooling has grown by leaps and bounds.
    Popular languages have strong support in multiple editors, linters, formatters, code review tools, and more.
    Even so, tools that support a wide variety of programming languages are hard to write and maintain.
</p>

<p>
    <a href="https://webassembly.org/">WebAssembly</a> (Wasm) as a compact, portable, and secure format for programs presents a new option for building polyglot tools:
    parsers written in <a href="https://github.com/appcypher/awesome-wasm-langs">Wasm-supporting languages</a> that can be leveraged by various tools.
</p>

<p>
    These could be generated by parser generators or written by hand,
    enable support for every class of language grammar,
    and can be consumed in any environment where Wasm can be run.
    So <a href="https://caniuse.com/wasm">any browser</a> and anywhere
    <a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a> can be run
    (hint: that&rsquo;s almost everywhere) would be able to use them.
</p>

<h2>Components and Interfaces</h2>

<p>
    WebAssembly has an evolving <a href="https://radu-matei.com/blog/intro-wasm-components/">component model</a>
    that makes it easier for WASM modules to talk to other modules through high-level interfaces.
    This allows us to create an interface definition <a href="https://github.com/bytecodealliance/wit-bindgen/blob/980007f19ff7933035491e6c7d9cfdf950d596fd/WIT.md">.wit</a>
    file that specifies what it means to be a parser.
</p>

<p>
    The simplest version of this might take in a string, and output a JSON representation of the parse tree.
</p>

<figure>
    <img
        src="/ewp/figure-0.webp"
        alt="parse: function(input: string) -> string"
    />
    <figcaption>A WIT interface for a parser that inputs and outputs strings</figcaption>
</figure>

<p>
    Once we define the output format, even this very simple interface is enough to get us started
    and enables us to write parsers in Wasm languages that work on any platform.
</p>

<p>
    This is still pretty low level though and doesn&rsquo;t offer very much structure (and potentially performance).
    It&rsquo;s also a bit silly that you have to then parse your parser output as JSON. We can do better.
</p>

<h2>A Higher Level Interface</h2>

<p>
    Let&rsquo;s make an interface that is higher level and actually encodes the structure of a parse tree
</p>

<h3>Tokens</h3>

<p>
    We&rsquo;ll start by defining a record type to represent <a href="https://en.wikipedia.org/wiki/Lexical_analysis#Token">tokens</a>.
</p>

<figure>
    <img
        src="/ewp/figure-1.webp"
        alt="Two types are defined: span which has an integer offset and length, and token which has a string label and a span"
    />
    <figcaption>A WIT interface for tokens (label + span) and spans (offset + length)</figcaption>
</figure>

<p>
    Each token gets a string label that identifies what kind of token it is (e.g. identifier, keyword)
    and a span that identifies what part of the input it represents.
    Span info is crucial to the functioning of formatters, linters, and many other tools.
</p>

<h3>Parse Tree</h3>

<p>
    Now that we can represent tokens, we need to represent the parse tree itself.
    Currently, the WIT format does not support recursive type definitions which are the typical way of doing this.
    Instead, we&rsquo;ll use indexes to provide a little indirection.
</p>

<figure>
    <img
        src="/ewp/figure-2.webp"
        alt="Three types are defined: a branch which contains a label and list of indices, the index type which is a variant and may refer to token or branches by index, and the output which is a list of branches and a list of tokens"
    />
    <figcaption>A WIT interface for branches which reference children by index</figcaption>
</figure>

<h3>The Parser</h3>

<p>
    Now we have all the tools we need to describe the parser interface.
    A parser simply transforms a string into parser output.
</p>

<figure>
    <img
        src="/ewp/figure-3.webp"
        alt="Defines a parse function which takes in an input string and outputs the output type defined in the prior figure"
    />
    <figcaption>A WIT interface for a parser that returns a structured output</figcaption>
</figure>

<p>
    Keen readers might notice that there is no explicit mention of error handling so far.
    In this simplified example, errors will simply be encoded as tokens and branches with a special label.
    Future expansions to EWPs could add more explicit error handling.
</p>

<h3>Implementing the Interface</h3>

<p>
    The interface we just wrote isn&rsquo;t hypothetical, we can implement it right now!
</p>

<p>
    Using Rust and the <a href="https://github.com/bytecodealliance/wit-bindgen">wit-bindgen</a> project
    we can create some scaffolding that looks like this. 
    The <code>wit_bindgen_rust</code> export line tells bindgen that we want to export the interface we defined,
    which just means that we will provide an implementation for other components to use.
</p>

<figure>
    <img
        src="/ewp/figure-4.webp"
        alt="Code demonstrating the basic use of wit-bindgen"
    />
    <figcaption>Rust code showing how wit-bindgen can be used for the parser interface</figcaption>
</figure>

<p>
    From there we just need to implement the tokenizing and parsing logic for our language of choice.
    I chose to use JSON since it is simple and practical.
    The source code for this is <a href="https://github.com/Kylebrown9/EWP/blob/main/ewp-json/src/lib.rs">available on GitHub</a> but is too long to cover in this article.
</p>

<h2>Consuming the Interface</h2>

<p>
    Now that we have defined a simple Embeddable WASM Parser interface and implemented it for a language,
    it&rsquo;s time to use that implementation to do something useful.
</p>

<h3>EWP Tool Example</h3>

<p>
    There are a wide variety of things you could do with the ability to parse arbitrary languages,
    but in the spirit of keeping things simple our example is just going to print the parse tree in a nice format.
</p>

<p>
    The tool will take in the path to a parser&rsquo;s WASM file and the file to parse and print out
    the parse tree as an <a href="https://en.wikipedia.org/wiki/S-expression">S-expression</a> like so.
</p>

<figure>
    <img
        src="/ewp/figure-5.webp"
        alt="Executing the test program to print out the s-expression of a simple input"
    />
    <figcaption>The tree-ewp tool being run to output a parenthesized parse tree</figcaption>
</figure>

<h3>Using a Runtime</h3>

<p>
    The tool is going to need to execute Embeddable WASM Parsers, which means it needs a runtime.
    We&rsquo;ll use <a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a> which is an official project of
    the <a href="https://bytecodealliance.org/">Bytecode Alliance</a>,
    a non-profit foundation building Open Source implementations of the standard.
</p>

<p>
    We&rsquo;ll create a new crate called <em>tree-ewp</em> with dependencies for running and talking to our WASM runtime.
</p>

<figure>
    <img
        class="downscale" 
        src="/ewp/figure-6.webp"
        alt="A Cargo.toml file showing a dependency on wasmtime and wit-bindgen"
    />
    <figcaption>The Cargo.toml file for the tree-ewp command line tool</figcaption>
</figure>

<p>
    In our code, we just instantiate the runtime, load and initialize our WASM file, execute the parse function, and then print the output.
</p>

<figure>
    <img class="downscale" src="/ewp/figure-7.webp"/>
    <figcaption>The high level implementation of the tree-ewp tool using wasmtime</figcaption>
</figure>

<p>
    Printing S-expressions is done with a few recursive functions that keep track of the indentation.
    You can see how that&rsquo;s done and the rest of the tree-ewp tool <a href="https://github.com/Kylebrown9/EWP/tree/main/tree-ewp">here</a>.
</p>

<h2>Wrap Up</h2>

<p>
    WebAssembly is an incredibly promising technology enabling new levels of security and portability for code.
    Its modularity allows us to share code conforming to specified interfaces as a way to solve specific problems,
    and it can be used to create portable parsers that we can run anywhere.
</p>