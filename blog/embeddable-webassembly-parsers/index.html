<!DOCTYPE html>
<html lang="en">

<head>
    
        
    

    
        
    

    <title>Embeddable WebAssembly Parsers | Esoterra</title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/style.css">

    <meta name="description" content="How Wasm lets us write portable solutions for parsing" />
    <meta name="keywords" content="Robin Brown,esoterra,programming,rust,webassembly,wasm">
    <link rel="author" href="https://hachyderm.io/@esoterra" />

    
        <link rel="canonical" href="https:&#x2F;&#x2F;esoterra.dev&#x2F;blog&#x2F;embeddable-webassembly-parsers&#x2F;" />
        <meta property="og:url" content="https:&#x2F;&#x2F;esoterra.dev&#x2F;blog&#x2F;embeddable-webassembly-parsers&#x2F;">
    

    <meta property="og:type" content="website" />
    <meta property="og:image" content="/banner.png">
    <meta property="og:description" content="How Wasm lets us write portable solutions for parsing">
    <meta property="og:title" content="Embeddable WebAssembly Parsers">
    <meta property="og:site_name" content="Esoterra">
    <meta property="og:see_also" content="https://esoterra.dev">
</head>

<body>
    <header>
        <nav>
            <a href="/">Home</a>
            <a href="/projects">Projects</a>
            <a href="/talks">Talks</a>
        </nav>
    </header>

    <main>
        
<article>
    <h1 class="title">Embeddable WebAssembly Parsers</h1>
    <p class="subtitle"><strong>How Wasm lets us write portable solutions for parsing</strong></p>
    <p>Developer tooling has grown by leaps and bounds.
Popular languages have strong support in multiple editors, linters, formatters, code review tools, and more.
Even so, tools that support a wide variety of programming languages are hard to write and maintain.</p>
<p><a href="https://webassembly.org/">WebAssembly</a> (Wasm) as a compact, portable, and secure format for programs presents a new option for building polyglot tools:
parsers written in <a href="https://github.com/appcypher/awesome-wasm-langs">Wasm-supporting languages</a> that can be leveraged by various tools.</p>
<p>These could be generated by parser generators or written by hand,
enable support for every class of language grammar,
and can be consumed in any environment where Wasm can be run.
So <a href="https://esoterra.dev/blog/embeddable-webassembly-parsers/%22https://caniuse.com/wasm%22">any browser</a> and anywhere <a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a> can be run
(hint: that’s almost everywhere) would be able to use them.</p>
<h2 id="components-and-interfaces"><a class="zola-anchor" href="#components-and-interfaces" aria-label="Anchor link for: components-and-interfaces">§</a>Components and Interfaces</h2>
<p>WebAssembly has an evolving <a href="https://radu-matei.com/blog/intro-wasm-components/">component model</a>
that makes it easier for WASM modules to talk to other modules through high-level interfaces.
This allows us to create an interface definition <a href="https://github.com/bytecodealliance/wit-bindgen/blob/980007f19ff7933035491e6c7d9cfdf950d596fd/WIT.md">.wit</a>
file that specifies what it means to be a parser.</p>
<p>The simplest version of this might take in a string, and output a JSON representation of the parse tree.</p>
<pre data-lang="js" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-js "><code class="language-js" data-lang="js"><span>parse: </span><span style="color:#569cd6;">function</span><span>(input</span><span style="color:#569cd6;">: </span><span>string) -&gt; string
</span></code></pre>
<p>Once we define the output format, even this very simple interface is enough to get us started
and enables us to write parsers in Wasm languages that work on any platform.</p>
<p>This is still pretty low level though and doesn't offer very much structure (and potentially performance).
It's also a bit silly that you have to then parse your parser output as JSON. We can do better.</p>
<h2 id="a-higher-level-interface"><a class="zola-anchor" href="#a-higher-level-interface" aria-label="Anchor link for: a-higher-level-interface">§</a>A Higher Level Interface</h2>
<p>Let's make an interface that is higher level and actually encodes the structure of a parse tree</p>
<h3 id="tokens"><a class="zola-anchor" href="#tokens" aria-label="Anchor link for: tokens">§</a>Tokens</h3>
<p>We'll start by defining a record type to represent <a href="https://en.wikipedia.org/wiki/Lexical_analysis#Token">tokens</a>.</p>
<pre data-lang="js" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-js "><code class="language-js" data-lang="js"><span>record token {
</span><span>    label: string,
</span><span>    span: span
</span><span>}
</span><span>
</span><span>record span {
</span><span>    offset: u32, </span><span style="color:#608b4e;">// The byte index where the token starts
</span><span>    length: u32, </span><span style="color:#608b4e;">// The number of bytes long the token is
</span><span>}
</span></code></pre>
<p>Each token gets a string label that identifies what kind of token it is (e.g. identifier, keyword)
and a span that identifies what part of the input it represents.
Span info is crucial to the functioning of formatters, linters, and many other tools.</p>
<h3 id="parse-tree"><a class="zola-anchor" href="#parse-tree" aria-label="Anchor link for: parse-tree">§</a>Parse Tree</h3>
<p>Now that we can represent tokens, we need to represent the parse tree itself.
Currently, the WIT format does not support recursive type definitions which are the typical way of doing this.
Instead, we'll use indexes to provide a little indirection.</p>
<pre data-lang="js" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-js "><code class="language-js" data-lang="js"><span>record branch {
</span><span>    label: string,
</span><span>    </span><span style="color:#608b4e;">// The nodes that this branch contains
</span><span>    children: list</span><span style="color:#569cd6;">&lt;</span><span>node-index</span><span style="color:#569cd6;">&gt;
</span><span>}
</span><span>
</span><span>variant node-index {
</span><span>    token(u32),  </span><span style="color:#608b4e;">// refers to the Nth token in output
</span><span>    branch(u32), </span><span style="color:#608b4e;">// refers to the Nth branch in output
</span><span>}
</span><span>
</span><span>record output {
</span><span>    tokens: list</span><span style="color:#569cd6;">&lt;</span><span>token</span><span style="color:#569cd6;">&gt;</span><span>,
</span><span>    tree: list</span><span style="color:#569cd6;">&lt;</span><span>branch</span><span style="color:#569cd6;">&gt;
</span><span>}
</span></code></pre>
<h3 id="the-parser"><a class="zola-anchor" href="#the-parser" aria-label="Anchor link for: the-parser">§</a>The Parser</h3>
<p>Now we have all the tools we need to describe the parser interface.
A parser simply transforms a string into parser output.</p>
<pre data-lang="js" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-js "><code class="language-js" data-lang="js"><span>parse: </span><span style="color:#569cd6;">function</span><span>(input</span><span style="color:#569cd6;">: </span><span>string) -&gt; output
</span></code></pre>
<p>Keen readers might notice that there is no explicit mention of error handling so far.
In this simplified example, errors will simply be encoded as tokens and branches with a special label.
Future expansions to EWPs could add more explicit error handling.</p>
<h3 id="implementing-the-interface"><a class="zola-anchor" href="#implementing-the-interface" aria-label="Anchor link for: implementing-the-interface">§</a>Implementing the Interface</h3>
<p>The interface we just wrote isn't hypothetical, we can implement it right now!</p>
<p>Using Rust and the <a href="https://github.com/bytecodealliance/wit-bindgen">wit-bindgen</a> project
we can create some scaffolding that looks like this.
The <code>wit_bindgen_rust</code> export line tells bindgen that we want to export the interface we defined,
which just means that we will provide an implementation for other components to use.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>wit_bindgen_rust::export</span><span style="color:#569cd6;">!</span><span>(</span><span style="color:#d69d85;">&quot;../parser1.wit&quot;</span><span>);
</span><span>
</span><span style="color:#569cd6;">struct </span><span>Parser1 {}
</span><span>
</span><span style="color:#569cd6;">impl </span><span>parser1::Parser1 </span><span style="color:#569cd6;">for </span><span>Parser1 {
</span><span>    </span><span style="color:#569cd6;">fn </span><span>parse(input: String) -&gt; parser1::Output {
</span><span>        </span><span style="color:#569cd6;">let</span><span> tokens = tokenize(</span><span style="color:#569cd6;">&amp;</span><span>input);
</span><span>        </span><span style="color:#569cd6;">let</span><span> tree = parse(</span><span style="color:#569cd6;">&amp;</span><span>tokens);
</span><span>        parser1::Output { tokens, tree }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>tokenize(input: </span><span style="color:#569cd6;">&amp;str</span><span>) -&gt; Vec&lt;Token&gt; {
</span><span>    </span><span style="color:#569cd6;">...
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>parse(input: </span><span style="color:#569cd6;">&amp;</span><span>[Token]) -&gt; Vec&lt;Branch&gt; {
</span><span>    </span><span style="color:#569cd6;">...
</span><span>}
</span></code></pre>
<p>From there we just need to implement the tokenizing and parsing logic for our language of choice.
I chose to use JSON since it is simple and practical.
The source code for this is available on <a href="https://github.com/esoterra/EWP/blob/main/ewp-json/src/lib.rs">GitHub</a>
but is too long to cover in this article.</p>
<h2 id="consuming-the-interface"><a class="zola-anchor" href="#consuming-the-interface" aria-label="Anchor link for: consuming-the-interface">§</a>Consuming the Interface</h2>
<p>Now that we have defined a simple Embeddable WASM Parser interface and implemented it for a language,
it's time to use that implementation to do something useful.</p>
<h3 id="ewp-tool-example"><a class="zola-anchor" href="#ewp-tool-example" aria-label="Anchor link for: ewp-tool-example">§</a>EWP Tool Example</h3>
<p>There are a wide variety of things you could do with the ability to parse arbitrary languages,
but in the spirit of keeping things simple our example is just going to print the parse tree in a nice format.</p>
<p>The tool will take in the path to a parser's WASM file and the file to parse and print out
the parse tree as an <a href="https://en.wikipedia.org/wiki/S-expression">S-expression</a> like so.</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>$ cargo run -- ../ewp_json.wasm ../test.json
</span><span>(Object
</span><span>    (LBrace)
</span><span>    (Entry
</span><span>        (String)
</span><span>        (Colon)
</span><span>        (Number)
</span><span>    )
</span><span>    (RBrace)
</span><span>)
</span></code></pre>
<h3 id="using-a-runtime"><a class="zola-anchor" href="#using-a-runtime" aria-label="Anchor link for: using-a-runtime">§</a>Using a Runtime</h3>
<p>The tool is going to need to execute Embeddable WASM Parsers, which means it needs a runtime.
We'll use <a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a> which is an official project of the <a href="https://bytecodealliance.org/">Bytecode Alliance</a>,
a non-profit foundation building Open Source implementations of the standard.</p>
<p>We'll create a new crate called <em>tree-ewp</em> with dependencies for running and talking to our WASM runtime.</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[</span><span style="color:#808080;">package</span><span>]
</span><span style="color:#569cd6;">name </span><span>= </span><span style="color:#d69d85;">&quot;tree-ewp&quot;
</span><span style="color:#569cd6;">version </span><span>= </span><span style="color:#d69d85;">&quot;0.1.0&quot;
</span><span style="color:#569cd6;">edition </span><span>= </span><span style="color:#d69d85;">&quot;2021&quot;
</span><span>
</span><span>[</span><span style="color:#808080;">dependencies</span><span>]
</span><span style="color:#569cd6;">wasmtime </span><span>= </span><span style="color:#d69d85;">&quot;0.33.0&quot;
</span><span style="color:#569cd6;">wit-bindgen-wasmtime </span><span>= { </span><span style="color:#ff3333;">... }
</span><span style="color:#ff3333;">...
</span></code></pre>
<p>In our code, we just instantiate the runtime, load and initialize our WASM file, execute the parse function, and then print the output.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// Set up WASMTIME
</span><span style="color:#569cd6;">let</span><span> engine = Engine::default();
</span><span style="color:#569cd6;">let mut</span><span> linker = Linker::new(</span><span style="color:#569cd6;">&amp;</span><span>engine);
</span><span style="color:#569cd6;">let mut</span><span> store = Store::new(</span><span style="color:#569cd6;">&amp;</span><span>engine, interface::Parser1Data {});
</span><span>
</span><span style="color:#608b4e;">// Load and initialize our EWP module
</span><span style="color:#569cd6;">let</span><span> wat = fs::read(args.ewp_path)
</span><span>    .expect(</span><span style="color:#d69d85;">&quot;Could not read EWP WASM module file&quot;</span><span>);
</span><span style="color:#569cd6;">let</span><span> module = Module::new(</span><span style="color:#569cd6;">&amp;</span><span>engine, wat)
</span><span>    .expect(</span><span style="color:#d69d85;">&quot;Could not initialize module&quot;</span><span>);
</span><span style="color:#569cd6;">let</span><span> result = interface::Parser1::instantiate(
</span><span>            </span><span style="color:#569cd6;">&amp;mut</span><span> store, </span><span style="color:#569cd6;">&amp;</span><span>module,
</span><span>            </span><span style="color:#569cd6;">&amp;mut</span><span> linker, get_whole_store
</span><span>    )
</span><span>    .expect(</span><span style="color:#d69d85;">&quot;Failed to instantiate interface&quot;</span><span>);
</span><span>
</span><span>
</span><span style="color:#608b4e;">// Read input file and parse it
</span><span style="color:#569cd6;">let</span><span> input = fs::read_to_string(args.input_path)
</span><span>    .expect(</span><span style="color:#d69d85;">&quot;Could not read pares input file&quot;</span><span>);
</span><span style="color:#569cd6;">let</span><span> output = result.</span><span style="color:#b5cea8;">1.</span><span>parse(</span><span style="color:#569cd6;">&amp;mut</span><span> store, </span><span style="color:#569cd6;">&amp;</span><span>input)
</span><span>    .expect(</span><span style="color:#d69d85;">&quot;Failed to run EWP&quot;</span><span>);
</span><span>
</span><span>printer::pretty_print(output);
</span></code></pre>
<p>Printing S-expressions is done with a few recursive functions that keep track of the indentation.
You can see how that's done and the rest of the tree-ewp tool in <a href="https://github.com/esoterra/EWP/tree/main/tree-ewp">the GitHub repo</a>.</p>
<h2 id="wrap-up"><a class="zola-anchor" href="#wrap-up" aria-label="Anchor link for: wrap-up">§</a>Wrap Up</h2>
<p>WebAssembly is an incredibly promising technology enabling new levels of security and portability for code.
Its modularity allows us to share code conforming to specified interfaces as a way to solve specific problems,
and it can be used to create portable parsers that we can run anywhere.</p>

</article>

    </main>
</body>

</html>